### jupyter notebook操作命令

```
单击B：在当前cell下新建一个cell

ctrl+Enter:  运行cell

Alt+Enter:  运行当前的cell，并在下一行新建一个cell

单击M：写命令模式转化为Markdown

单击Y:  Markdown模式转化为写命令模式

双击D：删除当前的cell

```

### ndarray属性

```python

  ndim:维度；  shape：形状（各维度的长度）  size：总长度   dtype：元素类型
例如：cat.ndim        cat.shape             cat.size         cat.dtype
  >>>3             >>>(456,730,3)        >>>998640        >>>dtype('unit8')

```

### 创建ndarray数组

```python
一维数组的创建

导入numpy库
import numpy as np
#列表创建
a = [1,2,3,4,5]
b = np.array(a)
b.shap 或 display(b.shape)  #b的维度形状

n1 = np.arange(10,step=2)   #0到9,步频为2

#linspace: 均分  ----创建0-100的偶数一维数组    
n = np.linspace(0, 100, num=50, dtype=int,retstep=True, endpoint=False)
>>>(array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
        34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
        68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98]), 2.0)
#从0到150，均分50份,最大+-128
n = np.linspace(0, 150, num=50, dtype=np.int8)
>>>array([   0,    3,    6,    9,   12,   15,   18,   21,   24,   27,   30,
         33,   36,   39,   42,   45,   48,   52,   55,   58,   61,   64,
         67,   70,   73,   76,   79,   82,   85,   88,   91,   94,   97,
        101,  104,  107,  110,  113,  116,  119,  122,  125, -128, -125,
       -122, -119, -116, -113, -110, -106], dtype=int8)

#numpy默认ndarray的所有元素的类型是相同的
#如果传进来的列表中包含不同的类型，则统一为同一类型，优先级：str>float>int
n1 = np.array(['0',5,3.5])
n1   
>>>array(['0','5','3.5'])

n2 = np.array([1,3.2,6])
n2
>>>array([1. ,3.2,6. ,])




创建二维数组

ones：全为1 -----  np.ones(shape, dtype=None, order='C')
n = np.ones((4,5))    #创建4行5列二维数组,默认值都为1
n = np.ones((2,2))    #创建2行2列单位矩阵
n1 = np.ones((2,5,6),dtype=int)     #创建2纵5行6列三维数组，默认值都为1


zeros: 全为0 -----  np.zeros(shape, dtype=float, order='C')
n2 = np.zeros((3,4))    #创建3行4列二维数组，值都为0


full: 填充为n --------  np.full(shape, fill_value, dtype=None, order='C')
n3 = np.full((4,5),dtype=int,fill_value=8)   #创建4行5列二维数组，值都为8


eye:  -----  eye(N, M=None, k=0, dtype=float) 对角线为1其他的位置为0
n = np.eye(4,5)    #创建4行5列二维数组

#创建4行4列满秩矩阵--有解
n = np.eye(4,4,dtype=int)
>>>array([[1, 0, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 1, 0],
          [0, 0, 0, 1]])


arange: 相当于python的range----- np.arange([start, ]stop, [step, ]dtype=None)
#创建1-9的数组
n = np.arange(10)  或者  n = np.arange(0,10)
#创建1-10之前的奇数数组,右边不包括
n = np.arange(1,10,step=2)


randint:随机取一个整数-----
np.random.randint(low, high=None, size=None, dtype='l')
#随机选取10以内的一个数
n = np.random.randint(10)


randn: 标准正太分布 ------- np.random.randn(d0, d1, ..., dn) 
标准正太分布 平均数为0，方差为1,（方差越小，就越向0集中） 参数10：为10个随机数 
n = np.random.randn(10)


normal:正太分布 ------np.random.normal(loc=0.0, scale=1.0, size=None)
#创建以175位中心，左右两边距离175的差值集中为5.0，的50个随机数
n = np.random.normal(175,scale=5.0,size=50)

random:0-1的随机数------np.random.rand(size=None) 
n = np.random.rand(10)


创建三维数组
n3 = np.random.randint(0,255,size=(3,4,5))

```

##### 常用快速生成数组

```python

n = np.random.randint(0,100,size=1000) #生成0-100的随机整数,生成1000个
n1 = np.random.rand(1000)  #生成1000个0-1的随机数
n2 = np.linspace(0,100,num=50) #生成均分50份0-100的数组
n3 = np.random.normal(175,scale=5.0,size=50)  #生成方差scale=5,50个数组
n4 = np.random.randn(10)   #生成10个标准正太分布数组
n5 = np.arange(10)    #生成0-9的10个数组
```

### 维度之间的转换

```python
#一维数组--->二维数组
n1 = np.array([1,2,3])
n2 = np.array([4,5,6])
np.c_[n1.n2]
>>>array([[1, 4],
          [2, 5],
          [3, 6]])

#二维数组 --->一维数组
n = np.random.randint(0,5,size=(2,3))
>>>array([[2, 1, 1],
          [0, 4, 4]])
a = np.ravel(n)
a
>>>array([2, 1, 1, 0, 4, 4])
```



### 索引

```python

#列表索引
a = [1,3,5,2,6]
a[2:4]
>>>[5,2]

#一维数组索引 ,从0开始
n = np.array(a)
n[2]
>>>5

#二维数组索引
n2 = np.random.randint(0,255,size=(4,4))
>>>array([[  8, 117, 209,  86],
          [156, 192, 117, 180],
          [ 33,  70,  53, 179],
          [ 56, 236,  72,  45]])
#从0开始数，第三行第四列
n2[2,3]
>>>179


#三维数组索引
n3 = np.random.randint(0,255,size=(3,4,5))
>>>array([[[ 80, 177,  23, 224, 235],
           [243,  78, 112,  27,  74],
           [199,  43,  17,  99,   3],
           [242,  10,  92, 228,  28]],

          [[126,  79, 182,  89, 134],
           [ 50,  94, 137,  49, 207],
           [171,  62,  52, 105, 237],
           [176, 158,  55, 179,  18]],

          [[176,  97, 148,  33,  17],
           [143,  57, 113, 111,  11],
           [ 18,  97, 208,  15, 126],
           [142, 181, 197,  35, 111]]])

#找到第二纵第三行第四列的数字
n3[1,2,3]
>>>105


```

### 切片

: --切片, ::--步频

```python
#二维数组切片
n2 = np.random.randint(0,255,size=(4,4))
>>>array([[119,  44, 225, 114],
          [182,  10, 163,  12],
          [147,  80, 206, 163],
          [243, 216,  38,  10]])

n2.shape
>>>(4,4)

n2[:,0]   # 获取第一列数据
>>>array([119, 182, 147, 243])
n2[0,:] # 获取第一行数据
>>>array([119,  44, 225, 114])
n2[:,:2]  #获取第一列和第二列数据
>>>array([[119, 44],[182,10],[147,80],[243,216]]) #二维数组

#三维切片(图片的变换)
#  列如:鱼的图片(三维数组)
fish[::-1,::]    #图片上下颠倒
fish[::,::-1]    #图片左右颠倒
fish[::,::,::-1] #图片颜色颠倒
```



### 翻转

```python

#列表的倒序
a = [1,3,4,5,6]
a[::-1]
>>>[6,5,4,3,1]

#一维数组倒序
a = np.arange(5)
>>>array([0,1,2,3,4])
b = a[::-1]
>>>array([4,3,2,1,0])

#二维数组倒序
n = np.random.randint(0,255,size=(3,4))
n
>>>array([[ 33, 135,  97, 220],
          [ 34, 122,  94, 228],
          [149,   8, 182,  92]])
#二维数组行的数字不变，列的翻转
n[::,::-1]
>>>array([[220,  97, 135,  33],
          [228,  94, 122,  34],
          [ 92, 182,   8, 149]])

#三维数组(图片的颜色 颠倒)
n = np.random.randint(0,255,size=(490,399,3))
n[::,::,::-1]
```



### 变形 ---reshape

```python

#使用reshape函数，注意参数是一个tuple！
n = np.arange(6)
n
>>>array([0, 1, 2, 3, 4, 5])

#转化成3行2列
n1 = np.reshape(n,(3,2))   #3*2=6
n1
>>>array([[0, 1],
          [2, 3],
          [4, 5]])


n = np.arange(20)
#转化成4行5列
n1 = np.reshape(n,(4,5))
n1
>>>>array([[0,1,2,3,4],
           [5,6,7,8,9],
           [10,11,12,13,14],
           [15,16,17,18,19]])

```

### 级联 ---concatenate

```python

1.np.concatenate() 级联需要注意的点：
2.级联的参数是列表：一定要加中括号或小括号
3.维度必须相同
4.形状相符
5.【重点】级联的方向默认是shape这个tuple的第一个值所代表的维度方向
6.可通过axis参数改变级联的方向

#两个二维2行3列数组相加
n1 = np.array([[1,2,3],[4,5,6]])
n2 = np.array([[7,8,9],[8,8,8]])
display(n1,n2)
>>>array([[1,2,3],
          [4,5,6]])
>>>array([[7,8,9],
          [8,8,8]])

#行拼接
np.concatenate((n1,n2))   #默认axis=0
>>>>>>array([[1,2,3],
             [4,5,6],
             [7,8,9],
             [8,8,8]])
#列拼接
np.concatenate((n1,n2),axis=1)  #或axis=-1
>>>array([[1, 2, 3, 7, 8, 9],
          [4, 5, 6, 8, 8, 8]])



#一维数组
n = np.array([1,2,3,4,5])
#水平级联hstack水平堆叠
np.hstack(n)
>>>array([1,2,3,4,5])
#垂直级联
np.vstack(n)
>>>array([[1],     #二维数组
          [2],
          [3],
          [4],
          [5]])


n = np.arange(6)
>>>array[0,1,2,3,4,5]
#升维
n1 = np.reshape(n,(3,2))  #二维3行2列
n1
>>>array([[0, 1],
          [2, 3],
          [4, 5]])
#降维
np.hstack(n1)
>>>array([0, 1, 2, 3, 4, 5])  #一维
或者
n1.reshape(6,)        n1.reshape(-1,)
>>>array([0, 1, 2, 3, 4, 5]) #一维
```

### 切割

```python
n1 = np.array([[1,2,3],[4,5,6],[7,8,9],[9,9,9]])
n1
>>>array([[1,2,3],
          [4,5,6],
          [7,8,9],
          [9,9,9]])
#从0开始,半闭半开
np.split(n1,[1,3])
>>>array([[1,2,3]]),
   array([[4,5,6],
          [7,8,9]]),
   array([[9,9,9]])

```

### 获取

```python
n1 = np.array([[1,2,3],[4,5,6],[7,8,9],[9,9,9]])
#获取第一和第三行
n1[[0,2]]
```



### 选择排序

```python
# 第一次从下标为0的开始下标为0的这个数与后面的n-1个进行比较；找出最小或者最大的放在下标为0的这个位置；
# 第二次从下标为1的开始比较；查询剩下的最大或者最小值；放在下标为1的位置
#通过确定一个Key最大或最小值，再从带排序的的数中找出最大或最小的交换到对应位置。
def select(n):
    for i in range(len(n)-1):
        #n[i:]切片中的最小下标，加上i则为整个列表下标
        index = np.argmin(n[i:])+i   
        n[i],n[index] = n[index],n[i]
    return n
  
n = [1,8,2,6,7,9]
select(n)
```

### 冒泡排序

```python
#冒泡排序
#通过重复走完数组的所有元素，通过打擂台的方式两个两个比较，直到没有数可以交换的时候结束这个数，
#再到下个数，直到整个数组排好顺序。因一个个浮出所以叫冒泡排序
def bubble_sort(a):
    for i in range(len(a)-1):
        for j in range(len(a)-1-i):
            if a[j] > a[j+1]:
                a[j],a[j+1] = a[j+1],a[j]
                
    return a
   
n1 = [4,6,3,7,8,9]
bubble_sort(n1)
    
```



### 快速排列

```python
1. 快速排序
#选定其中一个作为基准值,通过排序,分成以基准值为界左右两部分,左边的数值均小于或者等于基准值,
#右边的数值均大于或者等于基准值,通过递归调用同样的方法,最后将结果合并
np.sort()与ndarray.sort()都可以，但有区别：
•np.sort()不改变输入
a = np.random.randint(20,size=6)
n = np.sort()
a不变

•ndarray.sort()本地处理，不占用空间，但改变输入
a.sort()
a改变
```



### 副本

```

所有赋值运算不会为ndarray的任何元素创建副本。对赋值后的对象的操作也对原来的对象生效。
可使用copy()函数创建副本
```

### ndarray运算---广播机制

```python
ndarray广播机制的两条规则

- 规则一：为缺失的维度补1
- 规则二：假定缺失元素用已有值填充

```

### 作业

```python
# 12、给定数组[1, 2, 3, 4, 5]，如何得到在这个数组的每个元素之间插入3个0后的新数组？
a = np.arange(1,6)
b = np.zeros(17,dtype=int)
display(a,b)

b[::4] = a    #4表示步频
>>>array([1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 5])



# 13、给定一个二维矩阵，如何交换其中两行的元素？
A = np.arange(16).reshape(4,4)
A[[0,1]] = A[[1,0]]
 
  

# 15、创建一个5*3随机矩阵和一个3*2随机矩阵，求矩阵积  ----dot
# 广播机制
a = np.random.random((4,3))
b = np.random.random((3,2))
Z = np.dot(a,b)



# 17、打印出以下函数（要求使用np.zeros创建8*8的矩阵）
Z = np.zeros((8,8),dtype=int)
Z[1::2,::2] = 1   #第2行,步频为2;第1列,步频为2
Z[::2,1::2] = 1   #第1行,步频为2;第2列,步频为2
print(Z)
```









